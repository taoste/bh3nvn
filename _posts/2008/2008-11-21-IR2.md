---
layout: post
title: 细说红外编解码
date: 2008-11-21 10:43:05
categories:
- 日志
tags:
- 红外
---
现有的红外遥控包括两种方式：PWM（脉冲宽度调制）和PPM（脉冲位置调制）。

两种形式编码的代表分别为NEC、CX6122和PHILIPS的RC-5、RC-6以及将来的RC-7。

PWM（脉冲宽度调制）：以发射红外载波的占空比代表“0”和“1”。引导码为载波发射9ms，关断4.5ms。“0”为载波发射0.56ms,关断时间0.565ms；“1”为载波发射0.56ms,关断时间1.685ms；
调制频率fCAR=1/Tc=fOSC/12=37.91K，fOSC是晶振频率（455K陶瓷晶体）；占空比=T1/Tc=1/3。

使用 38kHz载波频率      
头码间隔为 9ms + 4.5ms    
使用16位客户代码    
使用8位数据代码和8位取反的数据代码    

数据格式包括引导码、用户码、数据码及数据码反码，编码一共是32位。红外遥控信号从引导码开始，接下来是16位客户代码，然后是8位数据代码和取反的二进制8位代码，最后的是1位结束位。

![](http://i1328.photobucket.com/albums/w532/xwlogic/51f1a413g6f9de8ac9f4a_zps63a0655c.jpg)

此种编码方式可以使用MCU的捕获功能实现，通过比较两次捕获的时间，来判断发射码，参考程序：
[http://xwlogic.github.io/2008/11/IR/](http://xwlogic.github.io/2008/11/IR/ "http://xwlogic.github.io/2008/11/IR/")

但并不是所有的编码器都是如此，比如TOSHIBA的TC9012，其引导码为载波发射4.5ms，关断时间4.5ms，其“0”为载波发射0.52ms,关断0.52ms,其“1”为载波发射0.52ms，关断1.04ms。
   
另一种编码方式是PPM（脉冲位置调制）：以发射载波的位置表示“0”和“1”。用从发射载波到关断载波为“0”，从关断载波到发射载波为“1”。其发射载波和不发射载波的时间相同，都为0.889ms，也就是每位的时间是固定的。

调制频率fCAR=1/Tc=fOSC/12=36K，fOSC是晶振频率（432K陶瓷晶体）；占空比=T1/Tc=1/3。
使用36 kHz载波频率    
双相编码（又名曼彻斯特编码）    
5位地址码,6位数据码    
1.778ms的恒定的位时间（即在36K载波下占64时钟周期）    
数据格式包括一个开始位（Start bit）、一个扩展位（Enlarge bit）、一个触发位（Toggle bit）、五个系统位和六个数据位。其中引导位只能是开始位“1”。触发位T在”0”和”1”之间翻转，每次按键按下变化一下。

程序设计，首先检测数据线PD2端的高电平是否维持3.5ms以上，开始检测起始码，2个"1" ，然后，以第2个起始码的上升沿作为第一个同步信号（用外部中断同步数据边沿，同步信号为每位中间的边沿），在该边沿后3/4位的时间点（1.33ms）对数据线进行采样并记录一个信号电平，若为"1"，下一个同步信号下降沿有效，若为"0"，下一个同步信号上升沿有效，如果从前一个同步边沿开始经过2.25ms时间后，仍没有检测到下一个同步边沿，说明接收错误，注意信号反相，采样到信号电平为高时，表示一个“0”码，相反表示一个“1”码
 
示意程序如下：

{% highlight cpp linenos %}

    //**********定时器一初始化**********
void timer1_init(void)
    {
     TCNT1H=0x00;
     TCNT1L=0x00;
     ICR1H=0x00;
     ICR1L=0x00;
     OCR1AH=0x0E;
     OCR1AL=0x10;
     OCR1BH=0x00;
     OCR1BL=0x00;
     TCCR1A=0x00;
     TCCR1B=0x00;
} 
     
SIGNAL(SIG_INTERRUPT0) //int0 interrupt
{
    TCNT1=0;
     if(CodeCnt==1)
     {// 收到第一个起始码, 准备状态转解码状态
      TCCR1B=0x01;// 开定时器
      CodeCnt=2;
      IrTemp=0;
      MCUCR=0x03; //第2个起始码的上升沿作为第一个同步信号
     }
     else
     {
       if(CodeCnt>13)
    {  // 完成解码
     IrCode=IrTemp;
     while(TCNT1<889); // 延时889us
     MCUCR=0x02;   // 恢复下降沿中断
     CodeCnt=0;   // 转空闲状态
    }
    else
    { 
     if(CodeCnt>1)
     { // 解码中，共12次 CodeCnt=2-13
      CodeCnt++;   // 转解码状态+1
      IrTemp<<=1;
      while(TCNT1<1320); // 延时1.33ms, 检测信号电平
      if(IrDat)
      { // 1，下一次下降沿有效
    IrTemp|=1;
    MCUCR=0x02;
       }
    else
    { // 0，下一次上升沿有效
     MCUCR=0x03;
    }
       }
      }
     }
}
    
SIGNAL(SIG_OUTPUT_COMPARE1A)
{
     if(CodeCnt==0)
     { // 空闲状态转准备状态
      TCCR1B=0;// 关定时器
      CodeCnt=1;
     }
     else
     {  // 错误，转空闲状态
      MCUCR=0x02;   // 恢复下降沿中断
      CodeCnt=0;
      TCNT1=0;
     }
}

{% endhighlight %}